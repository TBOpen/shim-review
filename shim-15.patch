diff -ur shim-15-org/Cryptlib/Makefile shim-15/Cryptlib/Makefile
--- shim-15-org/Cryptlib/Makefile	2018-04-05 11:49:17.000000000 -0700
+++ shim-15/Cryptlib/Makefile	2020-07-30 05:17:07.182897429 -0700
@@ -1,5 +1,10 @@
+ifeq ($(ARCH),x86_64)
+    ARCHFIX=x64
+else
+    ARCHFIX=$ARCH
+endif
 
-EFI_INCLUDES	= -I$(TOPDIR)/Include -I$(EFI_INCLUDE) -I$(EFI_INCLUDE)/$(ARCH) -I$(EFI_INCLUDE)/protocol
+EFI_INCLUDES	= -I$(TOPDIR)/Include -I$(EFI_INCLUDE) -I$(EFI_INCLUDE)/$(ARCHFIX) -I$(EFI_INCLUDE)/protocol
 
 CFLAGS		= -ggdb -O0 -I$(TOPDIR) -iquote $(TOPDIR) -fno-stack-protector -fno-strict-aliasing -fpic -fshort-wchar \
 		  -Wall $(EFI_INCLUDES) -std=gnu89 \
diff -ur shim-15-org/Cryptlib/OpenSSL/Makefile shim-15/Cryptlib/OpenSSL/Makefile
--- shim-15-org/Cryptlib/OpenSSL/Makefile	2018-04-05 11:49:17.000000000 -0700
+++ shim-15/Cryptlib/OpenSSL/Makefile	2020-07-30 05:17:34.063047474 -0700
@@ -1,6 +1,11 @@
+ifeq ($(ARCH),x86_64)
+    ARCHFIX=x64
+else
+    ARCHFIX=$ARCH
+endif
 
 EFI_INCLUDES	= -I$(TOPDIR)/../Include \
-		  -I$(EFI_INCLUDE) -I$(EFI_INCLUDE)/$(ARCH) -I$(EFI_INCLUDE)/protocol \
+		  -I$(EFI_INCLUDE) -I$(EFI_INCLUDE)/$(ARCHFIX) -I$(EFI_INCLUDE)/protocol \
 		  -I$(TOPDIR)/crypto/asn1 -I$(TOPDIR)/crypto/evp -I$(TOPDIR)/crypto/modes -I$(TOPDIR)/crypto/include
 
 CFLAGS		= -ggdb -O0 -I$(TOPDIR) -I$(TOPDIR)/.. -I$(TOPDIR)/../Include/ -I$(TOPDIR)/crypto \
diff -ur shim-15-org/lib/Makefile shim-15/lib/Makefile
--- shim-15-org/lib/Makefile	2018-04-05 11:49:17.000000000 -0700
+++ shim-15/lib/Makefile	2020-07-30 05:12:29.883349679 -0700
@@ -2,7 +2,7 @@
 
 LIBFILES = simple_file.o guid.o console.o execute.o configtable.o shell.o variables.o security_policy.o
 
-EFI_INCLUDES    = -I$(EFI_INCLUDE) -I$(EFI_INCLUDE)/$(ARCH) -I$(EFI_INCLUDE)/protocol -I$(TOPDIR)/../include \
+EFI_INCLUDES    = -I$(EFI_INCLUDE) -I$(EFI_INCLUDE)/$(ARCHFIX) -I$(EFI_INCLUDE)/protocol -I$(TOPDIR)/../include \
 		  -I$(TOPDIR)/CryptLib/Include/openssl/
 
 lib.a: $(LIBFILES)
diff -ur shim-15-org/Make.defaults shim-15/Make.defaults
--- shim-15-org/Make.defaults	2018-04-05 11:49:17.000000000 -0700
+++ shim-15/Make.defaults	2020-07-30 04:50:10.996881302 -0700
@@ -20,23 +20,31 @@
 DEBUGINFO	?= $(prefix)/lib/debug/
 DEBUGSOURCE	?= $(prefix)/src/debug/
 OSLABEL		?= $(EFIDIR)
-DEFAULT_LOADER	?= \\\\grub$(ARCH_SUFFIX).efi
+DEFAULT_LOADER	?= grub$(ARCH_SUFFIX).efi
+DEFAULT_LOADER_FROM_FILE ?= shim$(ARCH_SUFFIX).dat
 DASHJ		?= -j$(shell echo $$(($$(grep -c "^model name" /proc/cpuinfo) + 1)))
 
 ARCH		?= $(shell $(CC) -dumpmachine | cut -f1 -d- | sed s,i[3456789]86,ia32,)
+ifeq ($(ARCH),x86_64)
+    ARCHFIX=x64
+else
+    ARCHFIX=$ARCH
+endif
+
+
 OBJCOPY_GTE224	= $(shell expr `$(OBJCOPY) --version |grep ^"GNU objcopy" | sed 's/^.*\((.*)\|version\) //g' | cut -f1-2 -d.` \>= 2.24)
 
 SUBDIRS		= $(TOPDIR)/Cryptlib $(TOPDIR)/lib
 
 EFI_INCLUDE	?= /usr/include/efi
 EFI_INCLUDES	= -nostdinc -I$(TOPDIR)/Cryptlib -I$(TOPDIR)/Cryptlib/Include \
-		  -I$(EFI_INCLUDE) -I$(EFI_INCLUDE)/$(ARCH) -I$(EFI_INCLUDE)/protocol \
+		  -I$(EFI_INCLUDE) -I$(EFI_INCLUDE)/$(ARCHFIX) -I$(EFI_INCLUDE)/protocol \
 		  -I$(TOPDIR)/include -iquote $(TOPDIR) -iquote $(shell pwd)
 
 LIB_GCC		= $(shell $(CC) -print-libgcc-file-name)
 EFI_LIBS	= -lefi -lgnuefi --start-group Cryptlib/libcryptlib.a Cryptlib/OpenSSL/libopenssl.a --end-group $(LIB_GCC)
 
-EFI_CRT_OBJS 	= $(EFI_PATH)/crt0-efi-$(ARCH).o
+EFI_CRT_OBJS 	= $(EFI_PATH)/crt0-efi-$(ARCHFIX).o
 EFI_LDS		= $(TOPDIR)/elf_$(ARCH)_efi.lds
 
 CFLAGS		= -ggdb -O0 -fno-stack-protector -fno-strict-aliasing -fpic \
@@ -45,7 +53,10 @@
 		  -I$(shell $(CC) -print-file-name=include) \
 		  "-DDEFAULT_LOADER=L\"$(DEFAULT_LOADER)\"" \
 		  "-DDEFAULT_LOADER_CHAR=\"$(DEFAULT_LOADER)\"" \
-		  $(EFI_INCLUDES)
+		  $(EFI_INCLUDES) \
+		  "-DALLOW_32BIT_KERNEL_ON_X64" \
+		  "-DDISABLE_FALLBACK" \
+		  "-DDEFAULT_LOADER_FROM_FILE=L\"$(DEFAULT_LOADER_FROM_FILE)\""
 
 CLANG_BUGS	= $(if $(findstring gcc,$(CC)),-maccumulate-outgoing-args,)
 
diff -ur shim-15-org/shim.c shim-15/shim.c
--- shim-15-org/shim.c	2018-04-05 11:49:17.000000000 -0700
+++ shim-15/shim.c	2020-07-30 05:08:54.441147180 -0700
@@ -60,6 +60,7 @@
 static CHAR16 *second_stage;
 static void *load_options;
 static UINT32 load_options_size;
+static UINT32 second_stage_allocated;
 
 /*
  * The vendor certificate used for validating the second stage loader
@@ -185,15 +186,10 @@
 static int
 image_is_loadable(EFI_IMAGE_OPTIONAL_HEADER_UNION *PEHdr)
 {
-	/* If the machine type doesn't match the binary, bail, unless
-	 * we're in an allowed 64-on-32 scenario */
-	if (PEHdr->Pe32.FileHeader.Machine != machine_type) {
-		if (!(machine_type == IMAGE_FILE_MACHINE_I386 &&
-		      PEHdr->Pe32.FileHeader.Machine == IMAGE_FILE_MACHINE_X64 &&
-		      allow_64_bit())) {
-			return 0;
-		}
-	}
+	/* we're in protocol so allow booting signed x32 kernels */
+	if (PEHdr->Pe32.FileHeader.Machine != machine_type && !in_protocol) {
+		return 0;
+ 	}
 
 	/* If it's not a header type we recognize at all, bail */
 	switch (PEHdr->Pe32Plus.OptionalHeader.Magic) {
@@ -1463,6 +1459,9 @@
 static int
 should_use_fallback(EFI_HANDLE image_handle)
 {
+#if DISABLE_FALLBACK
+	return 0;
+#else
 	EFI_LOADED_IMAGE *li;
 	unsigned int pathlen = 0;
 	CHAR16 *bootpath = NULL;
@@ -1533,6 +1532,7 @@
 		FreePool(bootpath);
 
 	return ret;
+#endif
 }
 
 /*
@@ -1630,7 +1630,8 @@
  * Open the second stage bootloader and read it into a buffer
  */
 static EFI_STATUS load_image (EFI_LOADED_IMAGE *li, void **data,
-			      int *datasize, CHAR16 *PathName)
+			      int *datasize, CHAR16 *PathName, 
+			      BOOLEAN ignoremissingfile)
 {
 	EFI_STATUS efi_status;
 	EFI_HANDLE device;
@@ -1662,7 +1663,8 @@
 	 */
 	efi_status = root->Open(root, &grub, PathName, EFI_FILE_MODE_READ, 0);
 	if (EFI_ERROR(efi_status)) {
-		perror(L"Failed to open %s - %r\n", PathName, efi_status);
+		if (!ignoremissingfile || efi_status != EFI_NOT_FOUND)
+			perror(L"Failed to open %s - %r\n", PathName, efi_status);
 		goto error;
 	}
 
@@ -1882,7 +1884,7 @@
 		/*
 		 * Read the new executable off disk
 		 */
-		efi_status = load_image(li, &data, &datasize, PathName);
+		efi_status = load_image(li, &data, &datasize, PathName, FALSE);
 		if (EFI_ERROR(efi_status)) {
 			perror(L"Failed to load image %s: %r\n",
 			       PathName, efi_status);
@@ -2097,6 +2099,62 @@
 }
 
 /*
+ * Load file with name of image to run
+ */
+EFI_STATUS set_second_stage_from_file(EFI_HANDLE image_handle, EFI_LOADED_IMAGE *li)
+{
+	EFI_STATUS efi_status;
+	CHAR16 *PathName = NULL;
+	void *data = NULL;
+	int datasize;
+	EFI_DEVICE_PATH *devpath = NULL;
+
+	/*
+	 * Build a new path from the existing one plus the filename to the file with the name
+	 */
+	efi_status = generate_path(DEFAULT_LOADER_FROM_FILE, li, &devpath, &PathName);
+
+	if (efi_status != EFI_SUCCESS) {
+		perror(L"Unable to generate path %s: %r\n", DEFAULT_LOADER_FROM_FILE, efi_status);
+		return efi_status;
+	}
+	
+	/* don't need devpath */
+	FreePool(devpath);
+	devpath = NULL;
+
+	/*
+	 * Load the file if it exists
+	 */
+
+	efi_status = load_image(li, &data, &datasize, PathName, TRUE);
+
+	if (efi_status != EFI_SUCCESS) {
+		if (efi_status!=EFI_NOT_FOUND)
+			perror(L"Failed to load file %s: %r\n", PathName, efi_status);
+	}
+	/*
+	 * Check if the name appears valid
+	 */
+	else if ((datasize % sizeof(CHAR16)) == 0 &&
+            *((CHAR16*) data+(datasize/sizeof(CHAR16))-1)==0 &&
+	    StrLen((CHAR16*) data)==(datasize/sizeof(CHAR16))-1) {
+		/* Name appears valid so use it */
+		second_stage = (CHAR16*) data;	  
+		second_stage_allocated = 1;
+	}
+	else {
+		perror(L"Contents of %s are not supported\n", PathName);
+		efi_status=EFI_UNSUPPORTED;
+		FreePool(data);
+	}
+
+	FreePool(PathName);
+
+	return efi_status;
+}
+
+/*
  * Check the load options to specify the second stage loader
  */
 EFI_STATUS set_second_stage (EFI_HANDLE image_handle)
@@ -2120,6 +2178,8 @@
 		return efi_status;
 	}
 
+	set_second_stage_from_file(image_handle, li);
+
 	/* So, load options are a giant pain in the ass.  If we're invoked
 	 * from the EFI shell, we get something like this:
 
@@ -2299,6 +2359,10 @@
 			loader_str[i] = start[i];
 		loader_str[loader_len/2-1] = L'\0';
 
+		if (second_stage_allocated)
+			FreePool(second_stage);
+
+		second_stage_allocated = 1;
 		second_stage = loader_str;
 		load_options = remaining_size ? start + (loader_len/2) : NULL;
 		load_options_size = remaining_size;
@@ -2469,7 +2533,7 @@
 	/*
 	 * Free the space allocated for the alternative 2nd stage loader
 	 */
-	if (load_options_size > 0 && second_stage)
+	if (second_stage_allocated)
 		FreePool(second_stage);
 
 	console_fini();
